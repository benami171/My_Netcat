
/**
 * #include <getopt.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <unistd.h>

void run_program(char *args_as_string) {
    // tokenize the string - split by space
    char *token = strtok(args_as_string, " ");

    if (token == NULL) {
        fprintf(stderr, "No arguments provided\n");
        exit(1);
    }
    // create an array of strings to store the arguments
    char **args = (char **)malloc(sizeof(char *));
    int n = 0;          // number of arguments
    args[n++] = token;  // add the first argument

    // get the rest of the arguments
    while (token != NULL) {
        token = strtok(NULL, " ");                                // get the next token (NULL - take the next token from the previous string)
        args = (char **)realloc(args, (n + 1) * sizeof(char *));  // allocate memory for the new argument
        args[n++] = token;                                        // add the new argument and increment the number of arguments
    }

    // fork and execute the program
    int fd = fork();
    if (fd < 0) {  // fork failed
        fprintf(stderr, "Fork failed\n");
        exit(1);
    }

    if (fd == 0) {  // child process
        execvp(args[0], args);
        fprintf(stderr, "Exec failed\n");
        free(args);
        exit(1);
    } else {
        wait(NULL);  // wait for the child process to finish
        // free the memory
        free(args);
    }
}



int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s -e <value> [-b <value>] [-i <value>] [-o <value>]\n", argv[0]);
        exit(1);
    }

    int opt;
    char *e_value = NULL;
    char *b_value = NULL;
    char *i_value = NULL;
    char *o_value = NULL;

    while ((opt = getopt(argc, argv, "e:b:i:o:")) != -1) {
        switch (opt) {
            case 'e':
                e_value = optarg;
                break;
            case 'b':
                b_value = optarg;
                break;
            case 'i':
                i_value = optarg;
                break;
            case 'o':
                o_value = optarg;
                break;
            default:
                fprintf(stderr, "Usage: %s -e <value> [-b <value>] [-i <value>] [-o <value>]\n", argv[0]);
                exit(1);
        }
    }

    if (e_value == NULL) {
        fprintf(stderr, "Option -e is required\n");
        fprintf(stderr, "Usage: %s -e <value> [-b <value>] [-i <value>] [-o <value>]\n", argv[0]);
        exit(1);
    }

    if (b_value != NULL && (i_value != NULL || o_value != NULL)) {
        fprintf(stderr, "Option -b cannot be used with -i or -o\n");
        fprintf(stderr, "Usage: %s -e <value> [-b <value>] [-i <value>] [-o <value>]\n", argv[0]);
        exit(1);
    }

    int input_fd = STDIN_FILENO;
    int output_fd = STDOUT_FILENO;

    if (i_value != NULL) {
        i_value += 4;  // skip the "TCPS" prefix
        int port = atoi(i_value);

        // create TCP socket that will listen to input on localhost:port
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd == -1) {
            perror("error creating socket");
            return 1;
        }

        // bind the socket to the address

        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        addr.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
            perror("error binding socket");
            return 1;
        }

        // listen for incoming connections - at most 1
        if (listen(sockfd, 1) == -1) {
            perror("error listening on socket");
            return 1;
        }

        // accept the connection and change the input_fd to the new socket
        struct sockaddr_in client_addr;
        socklen_t client_addr_len = sizeof(client_addr);
        input_fd = accept(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);
        if (input_fd == -1) {
            perror("error accepting connection");
            return 1;
        }
    }

    if (o_value != NULL) {
        o_value += 4;  // skip the "TCPC" prefix
        char *server_ip = strtok(o_value, ",");
        if (server_ip == NULL) {
            fprintf(stderr, "Invalid server IP\n");
            exit(1);
        }
        // get the rest of the string after the comma
        char *server_port = strtok(NULL, ",");
        if (server_port == NULL) {
            fprintf(stderr, "Invalid server port\n");
            exit(1);
        }
        int port = atoi(server_port);

        // open a TCP client to the server
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd == -1) {
            perror("error creating socket");
            return 1;
        }

        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);

        if (inet_pton(AF_INET, server_ip, &addr.sin_addr) <= 0) {
            perror("Invalid address/ Address not supported");
            return 1;
        }

        if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
            perror("error connecting to server");
            if (input_fd != STDIN_FILENO) {
                close(input_fd);
            }
            return 1;
        }

        output_fd = sockfd;
    }

    if (b_value != NULL) {
        // open TCP server to listen to the port
        b_value += 4;  // skip the "TCPS" prefix
        int port = atoi(b_value);

        // create TCP socket that will listen to input on localhost:port
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd == -1) {
            perror("error creating socket");
            return 1;
        }

        // bind the socket to the address
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        addr.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
            perror("error binding socket");
            return 1;
        }

        // listen for incoming connections - at most 1
        if (listen(sockfd, 1) == -1) {
            perror("error listening on socket");
            return 1;
        }

        // accept the connection and change the input_fd to the new socket
        struct sockaddr_in client_addr;
        socklen_t client_addr_len = sizeof(client_addr);
        int new_fd = accept(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);
        if (new_fd == -1) {
            perror("error accepting connection");
            return 1;
        }

        input_fd = new_fd;
        output_fd = new_fd;
    }

    // create the pipeline
    int pipefd[2];  // pipefd[0] is the read end, pipefd[1] is the write end

    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }

    // fork and execute the program
    int fd = fork();
    if (fd < 0) {  // fork failed
        fprintf(stderr, "Fork failed\n");
        exit(1);
    }

    if (fd == 0) {  // child process
        if(input_fd != STDIN_FILENO) {
            if(dup2(input_fd, STDIN_FILENO) == -1) {
                perror("dup2");
                return 1;
            }
            close(input_fd);
        }
        if(output_fd != STDOUT_FILENO) {
            if(dup2(output_fd, STDOUT_FILENO) == -1) {
                perror("dup2");
                return 1;
            }
            close(output_fd);
        }

        run_program(e_value);


    } else {
        wait(NULL);  // wait for the child process to finish
    }

    return 0;
}
*/
